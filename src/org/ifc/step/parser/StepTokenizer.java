/* Generated By: IFC Tools Project EXPRESS TO JAVA COMPILER: Do not edit this file!! */
/* Generated By:JavaCC: Do not edit this line. StepTokenizer.java */
package org.ifc.step.parser;

import java.io.*;
import java.util.*;

import org.ifc.ifc2x3tc1.*;
import org.ifc.step.parser.util.*;

/**
 * Token Manager. *
 * <br><br>
 * Copyright: CC BY-NC-SA 3.0 DE (cc) 2013 Eike Tauscher and Michael Theiler<br><br>
 * The whole package including this class is licensed under<br>
 * <a rel='license' href='http://creativecommons.org/licenses/by-nc-sa/3.0/de/deed.en/'>
 * Creative Commons Attribution-Non-Commercial-Share Alike 3.0 Germany</a>.<br><br>
 * If you are using the package or parts of it in any commercial way, a commercial license is required.
 * Visit <a href='http://www.ifctoolsproject.com'>http://www.ifctoolsproject.com</a> for more information
 * or contact us directly: <a href='mailto:info@ifctoolsproject.com'>info@ifctoolsproject.com</a><br>
 */
public class StepTokenizer {
    public final static int EOF = 0;
    public final static int LPAREN = 9;
    public final static int RPAREN = 10;
    public final static int SEMICOLON = 15;
    public final static int COMMA = 17;
    public final static int DOLLAR = 20;
    public final static int STAR = 21;
    public final static int STANDARD_KEYWORD = 25;
    public final static int INTEGER = 27;
    public final static int REAL = 28;
    public final static int STRING = 30;
    public final static int ENTITY_INSTANCE_NAME = 31;
    public final static int ENUMERATION = 32;
    public final static int BINARY = 34;

    private static long stepCounter = 0;

    private static double progressStep = 10;

    private static int progress = 0;

    // private static HashMap<Integer, InternalAccessClass> nodeMap = null;
    private static ArrayEx<InternalAccessClass> nodeMap = null;

    private static Vector<StepParserProgressListener> listenerList = null;

    private static ProgressEvent event = new ProgressEvent(0, "");

    private static final NodeObject node = new NodeObject();

    private static File_Schema file_Schema = null;
    private static File_Description file_Description = null;
    private static File_Name file_Name = null;

    public StepTokenizer() {
    }

    public static void destruct() {
        nodeMap = null;
        listenerList = null;
        file_Schema = null;
        file_Description = null;
        file_Name = null;
        node.reset();
    }

    public static File_Schema getFile_Schema() {
        return file_Schema;
    }

    public static File_Description getFile_Description() {
        return file_Description;
    }

    public static File_Name getFile_Name() {
        return file_Name;
    }

    private static InternalAccessClass instantiateNode(NodeObject node1) {
        stepCounter++;
        InternalAccessClass object = null;
        try {
            object = (InternalAccessClass) ObjectFactory.createInstance(node1.getClassName());
            InternalAccess.setStepParameter(object, node1.getParameter());
            InternalAccess.setStepLineNumber(object, node1.getLineNumber());
            nodeMap.put(node1.getLineNumber(), object);
            if (stepCounter >= progressStep) {
                stepCounter = 0;
                progress++;
                event.setValues(progress, "parsing file...");
                fireProgressEvent();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return object;
    }

    public static void addStepParserProgressListener(StepParserProgressListener listener) {
        if (listenerList == null) listenerList = new Vector<StepParserProgressListener>();
        listenerList.add(listener);
    }

    public static void removeStepParserProgressListener(StepParserProgressListener listener) {
        if (listenerList != null) listenerList.remove(listener);
    }

    public static void removeAllStepParserPogressListeners() {
        listenerList = null;
    }

    private static void fireProgressEvent() {
        if (listenerList != null) {
            for (int i = 0;
                 i < listenerList.size();
                 i++) {
                StepParserProgressListener listener = (StepParserProgressListener) listenerList.get(i);
                listener.progressActionPerformed(event);
            }
        }
    }

//    private static void initLinesToRead(File file) throws IOException {
//        linesToRead = 0;
//        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));
//        while (bufferedReader.readLine() != null) {
//            linesToRead++;
//        }
//        progressStep = linesToRead / 100;
//    }

    public static ArrayEx<InternalAccessClass> startParsing(BufferedReader br) throws Exception {
        //init
//        progress = 0;
//        linesToRead = urlFileCache.getLineNumberCount();
//        progressStep = linesToRead / 100;

        //parse
        nodeMap = new ArrayEx<InternalAccessClass>(1024);
        parse(new BufferedReaderEx(br));
        return nodeMap;
    }

//    public static HashMap<Integer, InternalAccessClass> startParsing(File file) throws Exception {
//        progress = 0;
//        initLinesToRead(file);
//        nodeMap = new HashMap<Integer, InternalAccessClass>((int) linesToRead + 1);
//        parse(new BufferedReaderEx(new FileReader(file)));
//        return nodeMap;
//    }

    private static void parseHeader(Token t) throws Exception {
        StepTokenizer.getNextToken(); // ";"
        node.reset();
        node.setClassName(StepTokenizer.getNextToken().image);
        StepTokenizer.getNextToken(); // "("
        parseParameters(t);
        file_Description = (File_Description) ObjectFactory.createInstance(node.getClassName());
        InternalAccess.setStepParameter(file_Description, node.getParameter());
        node.reset();

        node.reset();
        node.setClassName(StepTokenizer.getNextToken().image);
        StepTokenizer.getNextToken(); // "("
        parseParameters(t);
        file_Name = (File_Name) ObjectFactory.createInstance(node.getClassName());
        InternalAccess.setStepParameter(file_Name, node.getParameter());
        node.reset();

        node.reset();
        node.setClassName(StepTokenizer.getNextToken().image);
        StepTokenizer.getNextToken(); // "("
        parseParameters(t);
        file_Schema = (File_Schema) ObjectFactory.createInstance(node.getClassName());
        InternalAccess.setStepParameter(file_Schema, node.getParameter());
        LIST<STRING> fileSchemes = (LIST<STRING>) InternalAccess.getStepParameter(file_Schema).get(0);
        String fileSchema = fileSchemes.get(0).getDecodedValue();
        if (!fileSchema.startsWith("IFC2X3")) {
            throw new Exception("File schema" + fileSchema + " is not supported");
        }
    }

    private static void parseParameters(Token t) {
        boolean entityEnd = false;
        while (!entityEnd) {
            t = StepTokenizer.getNextToken();
            switch (t.kind) {
                case ENTITY_INSTANCE_NAME: {
                    node.addParameter(new InstanceLineNoRef(t.intImage));
                    break;
                }
                case STANDARD_KEYWORD: {
                    NodeObject typedParameter = new NodeObject();
                    typedParameter.setClassName(t.image);
                    boolean inlineEnd = false;
                    while (!inlineEnd) {
                        t = StepTokenizer.getNextToken();
                        switch (t.kind) {
                            case COMMA:
                                break;
                            case RPAREN: {
                                inlineEnd = true;
                                break;
                            }
                            case LPAREN:
                                break;
                            default: {
                                typedParameter.addParameter(getType(t));
                                break;
                            }
                        }
                    }
                    node.addParameter(typedParameter);
                    break;
                }
                case REAL: {
                    node.addParameter(new DOUBLE(t.doubleImage));
                    break;
                }
                case DOLLAR: {
                    node.addParameter(null);
                    break;
                }
                case STAR: {
                    node.addParameter(null);
                    break;
                }
                case LPAREN: {
                    LIST list = new LIST();
                    node.addParameter(list);
                    boolean listEnd = false;
                    while (!listEnd) {
                        t = StepTokenizer.getNextToken();
                        switch (t.kind) {
                            case COMMA:
                                break;
                            case RPAREN: {
                                listEnd = true;
                                break;
                            }
                            default: {
                                list.add(getType(t));
                                break;
                            }
                        }
                    }
                    break;
                }
                case SEMICOLON: {
                    entityEnd = true;

                    break;
                }
                case STRING: {
                    node.addParameter(new STRING(t.image, false));
                    break;
                }
                case BINARY: {
                    node.addParameter(new BINARY(t.image.substring(1, t.image.length() - 1)));
                    break;
                }
                case INTEGER: {
                    node.addParameter(new INTEGER(t.intImage));
                    break;
                }
                case ENUMERATION: {
                    if (t.image.equals("T")) {
                        node.addParameter(LOGICAL.LogicalTrue); //type = type.concat(t.image);
                    } else if (t.image.equals("F")) {
                        node.addParameter(LOGICAL.LogicalFalse);
                    } else if (t.image.equals("U")) {
                        node.addParameter(LOGICAL.LogicalNull); //type = type.concat(t.image);
                    } else {
                        node.addParameter(new ENUM(t.image)); //type = type.concat("ENUM: " + t.image);
                    }
                    break;
                }
                default:
                    break;
            }
        }
    }

    private static void parse(BufferedReaderEx br) throws Exception {
        __input_stream = br;

        for (Token t = StepTokenizer.getNextToken();
             t.kind != EOF;
             t = StepTokenizer.getNextToken()) {

            if (t.image.startsWith("HEADER")) {
                parseHeader(t);
            }

            if (t.kind == ENTITY_INSTANCE_NAME) {
                node.reset();

                node.setLineNumber(t.intImage);
                StepTokenizer.getNextToken(); // "="

                node.setClassName(StepTokenizer.getNextToken().image);
                StepTokenizer.getNextToken(); // "("
                parseParameters(t);

                instantiateNode(node);
            }
        }
    }

    private static CloneableObject getType(Token t) {
        switch (t.kind) {
            case DOLLAR:
                return null;
            case STAR:
                return null;
            case ENTITY_INSTANCE_NAME:
                return new InstanceLineNoRef(t.intImage);
            case STANDARD_KEYWORD: {
                NodeObject typedParameter = new NodeObject();
                typedParameter.setClassName(t.image);
                StepTokenizer.getNextToken();
                boolean inlineEnd = false;
                while (!inlineEnd) {
                    t = StepTokenizer.getNextToken();
                    switch (t.kind) {
                        case COMMA:
                            break;
                        case RPAREN: {
                            inlineEnd = true;
                            break;
                        }
                        default: {
                            typedParameter.addParameter(getType(t));
                            break;
                        }
                    }
                }
                return typedParameter;
            }
            case LPAREN: {
                LIST list = new LIST();
                boolean listEnd = false;
                while (!listEnd) {
                    t = StepTokenizer.getNextToken();
                    switch (t.kind) {
                        case RPAREN: {
                            listEnd = true;
                            break;
                        }
                        default: {
                            list.add(getType(t));
                            break;
                        }
                    }
                }
                return list;
            }
            case STRING:
                return new STRING(t.image, false);
            case BINARY:
                return new BINARY(t.image.substring(1, t.image.length() - 1));
            case INTEGER:
                return new INTEGER(t.intImage);
            case REAL:
                return new DOUBLE(t.doubleImage);
            case ENUMERATION: {
                if (t.image.equals("T")) {
                    return LOGICAL.LogicalTrue; //new LOGICAL(true); //type = type.concat(t.image);
                } else if (t.image.equals("F")) {
                    return LOGICAL.LogicalFalse; //new LOGICAL(false);
                } else if (t.image.equals("U")) {
                    return LOGICAL.LogicalNull; //new LOGICAL(null); //type = type.concat(t.image);
                } else {
                    return new ENUM(t.image); //type = type.concat("ENUM: " + t.image);
                }
            }
            default:
                return null;
        }
    }

    static protected BufferedReaderEx __input_stream;

    public StepTokenizer(BufferedReaderEx stream) {
        __input_stream = stream;
    }

    private static char[] __static_string_buf = new char[8192];

    private static Token readString() {
//        StringBuilder sb = new StringBuilder(32);
//        sb.append("'");
        int idx = -1;
//        __static_string_buf[0] = '\'';

        int nextChar, curChar;
        while (true) {
            curChar = __input_stream.read();
            if (curChar == '\'') {
                nextChar = __input_stream.next();
                if (nextChar != '\'') {
                    break;
                } else {
                    __input_stream.commit();
                }
            }

            __static_string_buf[++idx] = (char) curChar;
        }

        return new Token(STRING, new String(__static_string_buf, 0, idx + 1));
    }

    private static void skipComment() {
        int nextChar, curChar;
        while (true) {
            curChar = __input_stream.read();
            nextChar = __input_stream.next();

            if (curChar == '*' && nextChar == '/') {
                break;
            }
        }

        __input_stream.commit();
    }

    private static char[] __static_keyword_buf = new char[8192];

    private static Token readNumber(char init) {
//        __static_keyword_buf[0] = init;
        UnsafeDoubleParser.init(init);

        int idx = 0;
        int nextChar = __input_stream.next();

        while (nextChar != ',' && nextChar != ')') {
//            __static_keyword_buf[++idx] = (char) nextChar;
//            if (nextChar == '.') {
//                realFlag = true;
//            }
            UnsafeDoubleParser.push((char) nextChar);
            nextChar = __input_stream.next();
        }

        if (UnsafeDoubleParser.isInteger()) {
            return new Token(INTEGER, UnsafeDoubleParser.evalInteger());
        } else {
            return new Token(REAL, UnsafeDoubleParser.evalDouble());
        }
//        String image = new String(__static_keyword_buf, 0, idx + 1);
//        return new Token(realFlag ? REAL : INTEGER, image);
    }

    private static Token readEnum() {

//        int idx = 0;
        int nextChar = __input_stream.next();

        if (nextChar >= '0' && nextChar <= '9') {
            // Real number
            UnsafeDoubleParser.init('.');

            while (nextChar != ',' && nextChar != ')') {
//                __static_keyword_buf[++idx] = (char) nextChar;
                UnsafeDoubleParser.push((char) nextChar);
                nextChar = __input_stream.next();
            }

            // return new Token(REAL, new String(__static_keyword_buf, 0, idx + 1));
            return new Token(REAL, UnsafeDoubleParser.evalDouble());
        } else {
            // Enum
//            __static_keyword_buf[0] = '.';
            int idx = -1;
            while (nextChar != '.') {
                __static_keyword_buf[++idx] = (char) nextChar;
                nextChar = __input_stream.next();
            }

            __input_stream.commit();
            return new Token(ENUMERATION, new String(__static_keyword_buf, 0, idx + 1));
        }
    }

    private static Token readName() {
        int nextChar = __input_stream.next();
        int num = 0;

        while (nextChar != ',' && nextChar != ')' && nextChar != '=') {
            num = num * 10 + (nextChar - (int) '0');
            nextChar = __input_stream.next();
        }

        return new Token(ENTITY_INSTANCE_NAME, num);
    }

    private static Token readKeyword(char init) {
        int idx = 0;
        __static_keyword_buf[0] = init;
        int nextChar = __input_stream.next();

        while (nextChar != '(' && nextChar != ';') {
            __static_keyword_buf[++idx] = (char) nextChar;
            nextChar = __input_stream.next();
        }

        return new Token(STANDARD_KEYWORD, new String(__static_keyword_buf, 0, idx + 1));
    }

    /**
     * Get the next Token.
     */
    private static Token getNextToken() {
        int nextChar;
        do {
            nextChar = __input_stream.read();
        } while (nextChar == ' ' || nextChar == '\r' || nextChar == '\n' || nextChar == '\t');

        switch (nextChar) {
            case -1:
                return new Token(EOF);
            case '/':
                skipComment();
                return getNextToken();
            case '=':
                return Token.NullToken;
            case ';':
                return Token.SemiColonToken;
            case ',':
                return Token.CommaToken;
            case '(':
                return Token.LParenToken;
            case ')':
                return Token.RParenToken;
            case '*':
                return Token.StarToken;
            case '$':
                return Token.DollarToken;
            case '\'':
                return readString();
            case '.':
                return readEnum();
            case '#':
                return readName();
            case '"':
                System.out.println("BINARY is not implemented because IFC seems not to need them");
                System.exit(0);
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case '-':
                return readNumber((char) nextChar);
            default:
                if (nextChar >= 'A' && nextChar <= 'Z') {
                    return readKeyword((char) nextChar);
                } else {
                    System.out.println("unknown: " + __input_stream.getCurLine() +
                            " : " + String.valueOf((char) nextChar));
                    return Token.NullToken;
                }
        }
    }

    private static List<Token> getTokensUntilEOI() {
        List<Token> ret = new ArrayList<Token>(16);
        int nextChar;

        while (true) {
            do {
                nextChar = __input_stream.read();
            } while (nextChar == ' ' || nextChar == '\r' || nextChar == '\n' || nextChar == '\t');

            switch (nextChar) {
                case '=':
                case ';':
                case -1:
                    return ret;
                case ',':
                    break;
                case '(':
                    System.out.println("Theoretically error");
                    System.exit(0);
                case ')':
                    break;
                case '*':
                    ret.add(Token.StarToken);
                    break;
                case '$':
                    ret.add(Token.DollarToken);
                    break;
                case '\'':
                    ret.add(readString());
                    break;
                case '.':
                    ret.add(readEnum());
                    break;
                case '#':
                    ret.add(readName());
                    break;
                case '"':
                    System.out.println("BINARY is not implemented because IFC seems not to need them");
                    System.exit(0);
                default:
                    if (nextChar >= 'A' && nextChar <= 'Z') {
                        ret.add(readKeyword((char) nextChar));
                    } else if ((nextChar >= '0' && nextChar <= '9') || nextChar == '-') {
                        ret.add(readNumber((char) nextChar));
                    } else {
                        System.out.println("unknown: " + __input_stream.getCurLine() +
                                " : " + String.valueOf((char) nextChar));
                    }
            }
        }
    }
}
