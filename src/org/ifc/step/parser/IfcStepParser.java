/* Generated By: IFC Tools Project EXPRESS TO JAVA COMPILER: Do not edit this file!! */
package org.ifc.step.parser;

import java.io.BufferedReader;
import java.util.*;

import org.ifc.ifc2x3tc1.*;
import org.ifc.step.parser.util.*;

/**
 * Copyright: CC BY-NC-SA 3.0 DE (cc) 2013 Eike Tauscher and Michael Theiler<br><br>
 * The whole package including this class is licensed under<br>
 * <a rel='license' href='http://creativecommons.org/licenses/by-nc-sa/3.0/de/deed.en/'>
 * Creative Commons Attribution-Non-Commercial-Share Alike 3.0 Germany</a>.<br><br>
 * If you are using the package or parts of it in any commercial way, a commercial license is required.
 * Visit <a href='http://www.ifctoolsproject.com'>http://www.ifctoolsproject.com</a> for more information
 * or contact us directly: <a href='mailto:info@ifctoolsproject.com'>info@ifctoolsproject.com</a><br>
 */
public class IfcStepParser {
    private static final String PACKAGE_NAME = "org.ifc.ifc2x3tc1.";

    //private static final long serialVersionUID = 1L;

    public static int errorCounter = 0;
    private Vector<StepParserProgressListener> listenerList = null;
    // private static HashMap<Integer, InternalAccessClass> entityInstanceNameMap = null;
    private static ArrayEx<InternalAccessClass> entityInstanceNameMap = null;
    private File_Schema file_Schema = null;
    private File_Description file_Description = null;
    private File_Name file_Name = null;

    /**
     * Constructs a new IfcStepParser object using standard parameters.
     */
    public IfcStepParser() {
    }

    /**
     * Registers a new StepParserProgressListener object to the parser, to
     * receive progress information see {@link StepParserProgressListener}.
     *
     * @param listener the listener object
     */
    public void addStepParserProgressListener(
            StepParserProgressListener listener) {
        if (listenerList == null) listenerList = new Vector<StepParserProgressListener>(1, 1);
        listenerList.add(listener);
    }

    private void fireProgressEvent(ProgressEvent event) {
        if (listenerList != null) {
            for (int i = 0; i < listenerList.size(); i++) {
                StepParserProgressListener listener = (StepParserProgressListener) listenerList
                        .get(i);
                listener.progressActionPerformed(event);
            }
        }
    }

    /**
     * Removes a StepParserProgressListener object.
     *
     * @param listener the listener to remove
     */
    public void removeStepParserProgressListener(
            StepParserProgressListener listener) {
        if (listenerList != null) listenerList.remove(listener);
        if (listenerList.size() == 0) listenerList = null;
    }

    /**
     * Removes all StepParserProgressListners from this object.
     */
    public void removeAllStepParserPogressListeners() {
        listenerList = null;
    }

    /**
     * Cleans up the memory.
     */
    public void destruct() {
        StepTokenizer.destruct();
        listenerList = null;
        entityInstanceNameMap = null;
        file_Description = null;
        file_Name = null;
        file_Schema = null;
    }


    /**
     * This method returns the IFC file's header entity FILE_SCHEMA.
     *
     * @return the header entity FILE_SCHEMA
     */
    public File_Schema getFile_Schema() {
        return file_Schema;
    }

    /**
     * This method returns the IFC file's header entity FILE_DESCRIPTION.
     *
     * @return the header entity FILE_DESCRIPTION
     */
    public File_Description getFile_Description() {
        return file_Description;
    }

    /**
     * This method returns the IFC file's header entity FILE_NAME.
     *
     * @return the header entity FILE_NAME
     */
    public File_Name getFile_Name() {
        return file_Name;
    }

    /**
     * Reads an IFC STEP file from the given URLFileCache object.
     *
     * @param br the BufferedReader object to read from.
     * @throws Exception exception is thrown if the file could not be read.
     */
    public void readStepFile(BufferedReader br) throws Exception {
        initReadStepFile();
        entityInstanceNameMap = StepTokenizer.startParsing(br);
        finishReadStepFile();
    }

    class InitNodeWorker implements Runnable {
        private int start;
        private int end;

        public InitNodeWorker(int start, int end) {
            this.start = start;
            this.end = (end == -1 ? entityInstanceNameMap.indexes().length : end);
        }

        public void run() {
            int[] indexes = entityInstanceNameMap.indexes();

            for (int i = start; i < end; i++) {
                InternalAccessClass node = entityInstanceNameMap.get(indexes[i]);
                if (node != null) {
                    initNode(node);
                    InternalAccess.setStepParameter(node, null);
                }
            }
        }
    }

    private void initReadStepFile() {
        StepTokenizer
                .addStepParserProgressListener(new StepParserProgressListener() {
                    public void progressActionPerformed(ProgressEvent event) {
                        fireProgressEvent(event);
                    }
                });
    }

    private void finishReadStepFile() {
        //HEADER
        initNode(file_Description = StepTokenizer.getFile_Description());
        initNode(file_Name = StepTokenizer.getFile_Name());
        initNode(file_Schema = StepTokenizer.getFile_Schema());

        StepTokenizer.destruct();
        System.runFinalization();

        fireProgressEvent(new ProgressEvent(0, "initialize objects..."));
        int counter = 0;
        int progress = 0;
        int progressStep = entityInstanceNameMap.size() / 100;

        for (int idx : entityInstanceNameMap.indexes()) {
            InternalAccessClass node = entityInstanceNameMap.get(idx);
            if (node != null) {
                initNode(node);
                InternalAccess.setStepParameter(node, null);
                counter++;
                if (counter >= progressStep) {
                    fireProgressEvent(new ProgressEvent(++progress,
                            "initialize objects..."));
                    counter = 0;
                }
            }
        }
//        int workerCount = 4;
//        int workerLoad = entityInstanceNameMap.size() / workerCount;
//        Thread[] workers = new Thread[workerCount];
//
//        for (int i = 0; i < workerCount; i++) {
//            int start = i * workerLoad;
//            int end = i == workerCount - 1 ? -1 : (i + 1) * workerLoad;
//
//            workers[i] = new Thread(new InitNodeWorker(start, end));
//            workers[i].start();
//        }
//
//        try {
//            for (int i = 0; i < workerCount; i++) {
//                workers[i].join();
//            }
//        } catch (InterruptedException e) {
//            // Something bad
//        }

        fireProgressEvent(new ProgressEvent(0, " "));
        System.runFinalization();
        System.gc();
    }

    private static Object resolveCollections(NodeObject nodeObject, String type) {
        type = type.toUpperCase();
        ArrayList<CloneableObject> parameters = nodeObject.getParameter();
        for (int i = 0; i < parameters.size(); i++) {
            CloneableObject object = parameters.get(i);
            if (object instanceof InstanceLineNoRef) {
                parameters.set(i, entityInstanceNameMap
                        .get(((InstanceLineNoRef) object).getLineNr()));
            } else if (object instanceof DOUBLE) {
                DOUBLE doubleObject = (DOUBLE) object;
                try {
                    DOUBLE integerParameter = (DOUBLE) ObjectFactoryMap.createInstance(type);
                    integerParameter.setValue(doubleObject.value);
                    parameters.set(i, integerParameter);
                } catch (Exception e) {
                    errorCounter++;
                    e.printStackTrace();
                }
            } else if (object instanceof STRING) {
                STRING stringObject = (STRING) object;
                try {
                    STRING stringParameter = (STRING) ObjectFactoryMap.createInstance(type);
                    stringParameter.setValue(stringObject);
                    parameters.set(i, stringParameter);
                } catch (Exception e) {
                    errorCounter++;
                    e.printStackTrace();
                }
            } else if (object instanceof LIST) {
                @SuppressWarnings("unchecked")
                LIST<CloneableObject> listObject = (LIST<CloneableObject>) object;
                try {
                    String className = listObject.getClass().getCanonicalName();
                    String nextType = className.substring(
                            className.indexOf("<"), className.lastIndexOf(">"));
                    resolveCollections(nodeObject, nextType);
                } catch (Exception e) {
                    errorCounter++;
                    e.printStackTrace();
                }
            } else if (object instanceof INTEGER) {
                INTEGER integerObject = (INTEGER) object;
                try {
                    INTEGER integerParameter = (INTEGER) ObjectFactoryMap.createInstance(type);
                    integerParameter.setValue(integerObject.value);
                    parameters.set(i, integerParameter);
                } catch (Exception e) {
                    errorCounter++;
                    e.printStackTrace();
                }
            } else if (object instanceof ENUM) {
                ENUM enumObject = (ENUM) object;
                try {
                    CloneableObject enumParameter = (ENUM) ObjectFactoryMap.createInstance(type);
                    ((ENUM) enumParameter).setValue(enumObject.stringValue);
                    parameters.set(i, enumParameter);
                } catch (Exception e) {
                    errorCounter++;
                    e.printStackTrace();
                }
            } else if (object instanceof BINARY) {
                BINARY byteObject = (BINARY) object;
                try {
                    BINARY byteParameter = (BINARY) ObjectFactoryMap.createInstance(type);
                    byteParameter.setValue(byteObject.value);
                    parameters.set(i, byteParameter);
                } catch (Exception e) {
                    errorCounter++;
                    e.printStackTrace();
                }
            } else if (object instanceof NodeObject) {
                NodeObject inlineObject = (NodeObject) object;
                try {
                    String className = inlineObject.getClassName();
                    CloneableObject inlineParameter = (CloneableObject) ObjectFactoryMap.createInstance(className);

                    if (inlineParameter instanceof InternalAccessClass) {
                        resolveCollections(inlineObject, className);
                        InternalAccess.initialize((InternalAccessClass) inlineParameter, inlineObject.getParameter());
                        parameters.set(i, inlineParameter);
                    } else {
                        resolveCollections(inlineObject, className);
                        ((TypeInterface) inlineParameter).setValue(inlineObject
                                .getParameter().get(0));
                        parameters.set(i, inlineParameter);
                    }
                } catch (Exception e) {
                    errorCounter++;
                    e.printStackTrace();
                }
            } else if (object instanceof LOGICAL) {
                LOGICAL logicalObject = (LOGICAL) object;
                try {
                    Object classObject = ObjectFactoryMap.createInstance(type);
                    if (BOOLEAN.class.isAssignableFrom(classObject.getClass())) {
                        BOOLEAN booleanParameter = (BOOLEAN) classObject;
                        booleanParameter.setValue(logicalObject.value);
                        parameters.set(i, booleanParameter);
                    } else {
                        LOGICAL logicalParameter = (LOGICAL) classObject;
                        logicalParameter.setValue(logicalObject.value);
                        parameters.set(i, logicalParameter);
                    }
                } catch (Exception e) {
                    errorCounter++;
                    e.printStackTrace();
                }
            }

        }
        return nodeObject;
    }

    private static Object initNode(InternalAccessClass ClassInterfaceObject) {
        ArrayList<CloneableObject> parameters = InternalAccess.getStepParameter(ClassInterfaceObject);
        for (int i = 0; i < parameters.size(); i++) {
            Object object = parameters.get(i);
            if (object instanceof InstanceLineNoRef) {
                parameters.set(i, entityInstanceNameMap
                        .get(((InstanceLineNoRef) object).getLineNr()));
            } else if (object instanceof DOUBLE) {
                DOUBLE doubleObject = (DOUBLE) object;
                String[] parameterList = null;
                try {
                    parameterList = InternalAccess.getNonInverseAttributeTypes(ClassInterfaceObject);
                    DOUBLE doubleParameter = (DOUBLE) ObjectFactoryMap.createInstance(parameterList[i].toUpperCase());
                    doubleParameter.setValue(doubleObject.value);
                    parameters.set(i, doubleParameter);
                } catch (Exception e) {
                    errorCounter++;
                    System.out.println("Handle DOUBLE");
                    System.out.println("Class: " + ClassInterfaceObject.getClass().getName());
                    System.out.println("STEP Line: " + ClassInterfaceObject.getStepLineNumber());
                    System.out.println("Parameter: " + parameters);
                    System.out.println("Parameter List: " + parameterList);
                    System.out.println("Index: " + i);
                }
            } else if (object instanceof STRING) {
                STRING stringObject = (STRING) object;
                String[] parameterList = null;
                try {
                    parameterList = InternalAccess.getNonInverseAttributeTypes(ClassInterfaceObject);
                    STRING stringParameter = (STRING) ObjectFactoryMap.createInstance(parameterList[i].toUpperCase());
                    stringParameter.setValue(stringObject);
                    parameters.set(i, stringParameter);
                } catch (Exception e) {
                    errorCounter++;
                    System.out.println("Handle STRING");
                    System.out.println("Class: "
                            + ClassInterfaceObject.getClass().getName());
                    System.out.println("STEP Line: "
                            + ClassInterfaceObject.getStepLineNumber());
                    System.out.println("Parameter: " + parameters);
                    System.out.println("Parameter List: " + parameterList);
                    System.out.println("Index: " + i);
                }
            } else if (object instanceof LIST) {
                @SuppressWarnings("unchecked")
                LIST<CloneableObject> listObject = (LIST<CloneableObject>) object;
                try {
                    String[] parameterList = InternalAccess.getNonInverseAttributeTypes(ClassInterfaceObject);
                    String className = parameterList[i];

                    if ((className.contains("SET") || className.contains("LIST"))) {
                        String nextType = className.substring(
                                className.indexOf("<") + 1,
                                className.lastIndexOf(">"));
                        NodeObject dummyObject = new NodeObject();
                        dummyObject.setParameter(listObject);
                        dummyObject.setClassName(nextType);
                        resolveCollections(dummyObject, nextType);

                        if (parameterList[i].contains("SET")) {
                            parameters.set(i, new SET<CloneableObject>(dummyObject.getParameter()));
                        } else {
                            parameters.set(i, new LIST<CloneableObject>(dummyObject.getParameter()));
                        }
                    } else {
                        Class<?> parameterClass = Class.forName(PACKAGE_NAME + className);
                        String superClassName = parameterClass.getGenericSuperclass().toString();
                        superClassName = superClassName.replace(PACKAGE_NAME, "");
                        String nextType = superClassName.substring(
                                superClassName.indexOf("<") + 1,
                                superClassName.lastIndexOf(">"));
                        NodeObject dummyObject = new NodeObject();
                        dummyObject.setParameter(listObject);
                        dummyObject.setClassName(nextType);
                        resolveCollections(dummyObject, nextType);
                        TypeInterface TypeInterface = (TypeInterface) ObjectFactoryMap.createInstance(className.toUpperCase());
                        TypeInterface.setValue(dummyObject.getParameter());
                        parameters.set(i, TypeInterface);
                    }
                } catch (Exception e) {
                    errorCounter++;
                    System.out.println("Handle LIST");
                    System.out.println("STEP Line: " + ClassInterfaceObject.getStepLineNumber());
                    System.out.println("Index: " + i);
                    System.out.println("Instantiated: " + ClassInterfaceObject.getClass().getName());
                }
            } else if (object instanceof ENUM) {
                ENUM enumObject = (ENUM) object;
                String[] parameterList = null;
                try {
                    parameterList = InternalAccess.getNonInverseAttributeTypes(ClassInterfaceObject);
                    CloneableObject enumParameter = (ENUM) ObjectFactoryMap.createInstance(parameterList[i].toUpperCase());
                    ((ENUM) enumParameter).setValue(enumObject.stringValue);
                    parameters.set(i, enumParameter);
                } catch (ArrayIndexOutOfBoundsException e) {
                    System.out.println("To many parameters for initializing");
                    System.out.println("Class: " + ClassInterfaceObject.getClass().getName());
                    System.out.println("STEP Line: " + ClassInterfaceObject.getStepLineNumber());
                    System.out.println("Parameter: " + parameters);
                    System.out.println("Index: " + i);
                    System.out.println("Parameter at index " + i + " has been ignored!\n");
                    parameters.remove(i);
                } catch (Exception e) {
                    errorCounter++;
                    System.out.println("Handle ENUM");
                    System.out.println("Class: " + ClassInterfaceObject.getClass().getName());
                    System.out.println("STEP Line: " + ClassInterfaceObject.getStepLineNumber());
                    System.out.println("Parameter: " + parameters);
                    System.out.println("Parameter List: " + parameterList);
                    System.out.println("Index: " + i);

                    e.printStackTrace();
                }
            } else if (object instanceof INTEGER) {
                INTEGER integerObject = (INTEGER) object;
                String[] parameterList = null;
                try {
                    parameterList = InternalAccess.getNonInverseAttributeTypes(ClassInterfaceObject);
                    INTEGER integerParameter = (INTEGER) ObjectFactoryMap.createInstance(parameterList[i].toUpperCase());
                    integerParameter.setValue(integerObject.value);
                    parameters.set(i, integerParameter);
                } catch (Exception e) {
                    e.printStackTrace();
                    errorCounter++;
                    System.out.println("Handle INTEGER");
                    System.out.println("Class: " + ClassInterfaceObject.getClass().getName());
                    System.out.println("STEP Line: " + ClassInterfaceObject.getStepLineNumber());
                    System.out.println("Parameter: " + parameters);
                    System.out.println("Parameter List: " + parameterList);
                    System.out.println("Index: " + i);
                }
            } else if (object instanceof BINARY) {
                BINARY byteObject = (BINARY) object;
                String[] parameterList = null;
                try {
                    parameterList = InternalAccess.getNonInverseAttributeTypes(ClassInterfaceObject);
                    BINARY byteParameter = (BINARY) ObjectFactoryMap.createInstance(parameterList[i].toUpperCase());
                    byteParameter.setValue(byteObject.value);
                    parameters.set(i, byteParameter);
                } catch (Exception e) {
                    errorCounter++;
                    System.out.println("Handle BINARY");
                    System.out.println("Class: " + ClassInterfaceObject.getClass().getName());
                    System.out.println("STEP Line: " + ClassInterfaceObject.getStepLineNumber());
                    System.out.println("Parameter: " + parameters);
                    System.out.println("Parameter List: " + parameterList);
                    System.out.println("Index: " + i);
                }
            } else if (object instanceof NodeObject) {
                NodeObject inlineObject = (NodeObject) object;
                try {
                    String className = inlineObject.getClassName();
                    CloneableObject inlineParameter = (CloneableObject) ObjectFactoryMap.createInstance(className);

                    if (inlineParameter instanceof InternalAccessClass) {
                        resolveCollections(inlineObject, className);
                        InternalAccess.initialize((InternalAccessClass) inlineParameter, inlineObject.getParameter());
                        parameters.set(i, inlineParameter);
                    } else {
                        resolveCollections(inlineObject, className);
                        ((TypeInterface) inlineParameter).setValue(inlineObject
                                .getParameter().get(0));
                        parameters.set(i, inlineParameter);
                    }
                } catch (Exception e) {
                    errorCounter++;
                    System.out.println("Handle INLINE");
                    System.out.println("Class: " + ClassInterfaceObject.getClass().getName());
                    System.out.println("STEP Line: " + ClassInterfaceObject.getStepLineNumber());
                    System.out.println("Parameter: " + parameters);
                    System.out.println("Index: " + i);
                }
            } else if (object instanceof LOGICAL) {
                LOGICAL logicalObject = (LOGICAL) object;
                Boolean tester = logicalObject.value;
                try {
                    String[] parameterList = InternalAccess.getNonInverseAttributeTypes(ClassInterfaceObject);
//                    System.out.println(PACKAGE_NAME + parameterList[i]);
                    String classname = parameterList[i];
                    // Class<?> classObject = Class.forName(PACKAGE_NAME + parameterList[i]);
                    if (classname.equals("BOOLEAN")) {
                        parameters.set(i, tester ? BOOLEAN.BooleanTrue : BOOLEAN.BooleanFalse);
                    } else if (classname.equals("IfcBoolean")) {
                        parameters.set(i, new IfcBoolean(logicalObject.value));
                    } else if (classname.equals("LOGICAL")) {
                        parameters.set(i, new LOGICAL(logicalObject.value));
                    } else if (classname.equals("IfcLogical")) {
                        parameters.set(i, new IfcLogical(logicalObject.value));
                    } else {
                        throw new Exception();
                    }

//                    if (BOOLEAN.class.isAssignableFrom(classObject)) {
//                        BOOLEAN booleanParameter = (BOOLEAN) classObject.newInstance();
//                        booleanParameter.setValue(logicalObject.value);
//                        parameters.set(i, booleanParameter);
//                    } else {
//                        LOGICAL logicalParameter = (LOGICAL) classObject.newInstance();
//                        logicalParameter.setValue(logicalObject.value);
//                        parameters.set(i, logicalParameter);
//                    }
                } catch (Exception e) {
                    errorCounter++;
                    System.out.println("Handle LOGICAL");
                    System.out.println("Class: " + ClassInterfaceObject.getClass().getName());
                    System.out.println("STEP Line: " + ClassInterfaceObject.getStepLineNumber());
                    System.out.println("Parameter: " + parameters);
                    System.out.println("Index: " + i);
                }
            }
        }
        try {
            InternalAccess.initialize(ClassInterfaceObject, parameters);
            InternalAccess.setStepParameter(ClassInterfaceObject, null);
        } catch (Exception e) {
            System.out.println("## Init " +
                    entityInstanceNameMap.get(ClassInterfaceObject.getStepLineNumber()) +
                    " using: ");
            System.out.println("## " + parameters);
            System.out.println("STEP Line: " + "#" + ClassInterfaceObject.getStepLineNumber());
            errorCounter++;
            e.printStackTrace();
        }

        return ClassInterfaceObject;

    }

    /**
     * This method returns all IFC objects that were parsed.
     *
     * @return the IFC obejcts
     */
    public Collection<InternalAccessClass> getIfcObjects() {
        return Arrays.asList(entityInstanceNameMap.values());
    }

    /**
     * This Method returns a sorted list of all parsed IFC objects. The IFC
     * objects are sorted by their STEP entity instance names.
     *
     * @return sorted list of IFC objects
     */
    public List<InternalAccessClass> getIfcObjectsSorted() {
        Arrays.sort(entityInstanceNameMap.indexes());
        List<InternalAccessClass> ret =
                new ArrayList<InternalAccessClass>(entityInstanceNameMap.indexes().length);

        for (int i : entityInstanceNameMap.indexes()) {
            ret.add(entityInstanceNameMap.get(i));
        }
        return ret;
    }

    /**
     * This method returns a HashMap object that has the entity instance name as
     * key and its corresponding IFC object as value.
     *
     * @return the entity instance name, IFC object mapping
     */
    public ArrayEx<InternalAccessClass> getEntityInstanceNameMap() {
        return entityInstanceNameMap;
    }
}
